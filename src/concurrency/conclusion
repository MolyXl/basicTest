并发不一定快,主要浪费在切换上下文
减少上下文切换的方法有:无锁并发编程、CAS算法、使用最少线程和使用协程。
    ·无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。
    ·CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。
    ·使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。
    ·协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。
现在我们介绍避免死锁的几个常见方法
    ·避免一个线程同时获取多个锁。
    ·避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
    ·尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。
    ·对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。
volatile的应用:保证了共享变量的“可见性”
    原理:处理器缓存写入内存时,会将这个内存数据在其他处理器的缓存置为失效,再次读取时从内存获取(此处内存指内存缓存,并非真正内存)
锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态